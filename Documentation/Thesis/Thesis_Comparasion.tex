%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                      %
%     File: Thesis_Results.tex                                         %
%     Tex Master: Thesis.tex                                           %
%                                                                      %
%                                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Comparison with existing technologies}
\label{chapter:comparison}

\section{Overview}
\label{section:overview}

This chapter compares the current technologies and new implemented approach. This comparation is done qualitatively and quantatively. The aim of this chapter is to summarize the advantages and disadvantages of new approach, compared to the current technologies.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Qualitatively and Quantatively Comparison}
\subsection{Textual or binary representation}
\label{section:textualbinary}
Current integration technologies for distributed systems in Cloud environment are generally supported on textual data description languages (XML and JSON) and HTTP protocol. These technologies especially designed for human-level interaction and that creates integration problems.

As described before, SOA is usually implemented by Web Services with WSDL, which is a set of conventions on XML usage to describe services at the interface level and SOAP as a message protocol, which is again based on XML. Many developers found SOAP cumbersome and hard to use. For example, working with SOAP in JavaScript means writing a ton of code to perform extremely simple tasks because you must create the required XML structure absolutely every time. one perceived disadvantage is the use of XML because of the verboseness of it and the time it takes to parse.

REST also requires that data types, which are usually, called media types and standardized or previously agreed, when they are application specific. REST doesn’t have to use XML to provide the response. You can find REST-based Web services that output the data in Command Separated Value (CSV), JavaScript Object Notation (JSON) and Really Simple Syndication (RSS). The point is that you can obtain the output you need in a form that’s easy to parse within the language you need for your application. While this may seem like it adds complexity to REST because you need to handle multiple formats, JSON usually is a better fit for data and parses much faster. REST allows better support for browser clients due to its support for JSON.

SOA and REST use textual representation but textual representation brings parsing expenses and poor support for binary data. When using these solutions you need to produce a client stub, Schema validation and also DOM parsing. All these expenses are a big deal for performance and create complexity in terms of usability. Instead of using textual representation, the binary representation provides native support for binary data, has a smaller length and is faster to parse. Section \ref{section:binaryLevelSerialization} with Figure \ref{fig:executiontime} proves that using binary data has more advantage than using XML or JSON.

The implemented approach in new solution is designed to work with binary representation. The binary representation uses a modified version of the TLV format (Tag, Length and Value) used by ASN.1 \citep{asn1:opt}. This not only supports the direct integration of binary information but also facilitates parsing, since each resource, primitive or structured. The advantage of using binary data eliminates stub generation, schema validation or DOM parsing expenses.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Message protocol}
\label{section:mprotocol}

Current solutions of distributed applications use message protocol to communicate each other. SOAP can use almost any transport to send the request, using everything from the before mentioned to SMTP (Simple Mail Transfer Protocol) and even JMS (Java Messaging Service), but REST has restrictions because REST requires use of only HTTP/HTTPS.

The approach in implemented in thesis does not depend on any particular transport protocol, relying only on message delivery. Any existing server can be used, based on HTTP, WebSockets or any other protocol. In fact, several servers can be used simultaneously, receiving messages that are handed over to the message handlers that are able to process them.

Advantage of using a new protocols, such as WebSockets, reduce some of the problems. Because Web Sockets, now part of the HTML5 world, removes this restriction, adds binary support and increases performance.   Using a platform which use Websocket or HTTP/2 will increase usability and performance regarding message transportation.

As seen in section \ref{section:messageTransfer}, there is big difference in terms of performance using WebSockets instead of using HTTP-based solutions. Regarding that the implemented solution in this thesis gives big advantage by supporting new protocols such as WebSockets or HTTP/2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The interoperability problem}
\label{section:interoperabilityProblem}

As seen in previous chapters that in both SOA and REST, interoperability is achieved by using common data types (usually structured), either by sharing a schema (i.e., WSDL files) or by using a previously agreed data type (typical in RESTful applications). There is usually no support for partial interoperability and polymorphism in distributed systems.

The basis of data interoperability with XML and JSON is schema sharing(at runtime or with previously standardized or agreed upon internet media types). Both the producer and consumer (reader) of a document should use the same schema, to ensure that any document produced (with that schema) can be read by the consumer. This means that both producer and consumer will be coupled by this schema. Schemas must be shared between interacting Web Services, establishing coupling for all the possible values satisfying each schema, even if they are not actually used. Additionally you can not change schema without informing both client and server. So you can not change either the client or the server without breaking interoperability.
%Searching for an interoperable Web Service is usually done by schema matching with similarity algorithms \citep{expertsystems:x1} and ontology matching and mapping \citep{Ontology:matching}. This does not ensure interoperability and manual adaptations are usually inevitable.
%REST also requires that data types (usually called media types) must have been previously agreed, either standardized or application specific.

New solution proposes to use partial interoperability, based on the concepts of compliance and conformance. It introduces a different perspective, stronger than similarity but weaker than commonality (sharing). The trick is to allow partial interoperability, by considering only the intersection between what the consumer needs and what the provider offers. It allows for increased interoperability, adaptability and changeability, without the need to have resource types necessarily shared or previously agreed.  Building interoperability on compliance and conformance avoids the problem of having to define schemas as separate documents and to agree upon them beforehand. As long as compliance and conformance hold, any two resources can interoperate, even if they were designed unawares to each other.

As seen in the example of Section \ref{section:AsymmetricInteroperability}, client or the server without breaking interoperability can change their structure of messages. This brings great facility both client and the server by reducing coupling.
